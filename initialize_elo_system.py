#!/usr/bin/env python3
"""
üìä INITIALISATION SYST√àME ELO
Script pour initialiser les collections MongoDB et donn√©es d'exemple pour le syst√®me ELO
"""

import asyncio
import sys
import os
import random
sys.path.append('/app/backend')

from motor.motor_asyncio import AsyncIOMotorClient
from datetime import datetime, timedelta
import uuid
from typing import Dict, Any, List

# Configuration de la base de donn√©es
from database import db, client

async def create_elo_collections():
    """Cr√©er les collections n√©cessaires pour le syst√®me ELO"""
    try:
        print("üóÑÔ∏è Cr√©ation des collections pour le syst√®me ELO...")
        
        # 1. Collection pour les ratings ELO des utilisateurs
        await db.create_collection("elo_ratings")
        print("  ‚úÖ Collection 'elo_ratings' cr√©√©e")
        
        # 2. Collection pour l'historique des matchs ELO
        await db.create_collection("elo_matches")
        print("  ‚úÖ Collection 'elo_matches' cr√©√©e")
        
        # 3. Collection pour les stats saisonni√®res
        await db.create_collection("season_stats")
        print("  ‚úÖ Collection 'season_stats' cr√©√©e")
        
        # 4. Cr√©er les index pour optimiser les performances
        await create_elo_indexes()
        
        return True
        
    except Exception as e:
        if "already exists" in str(e).lower():
            print("  ‚ÑπÔ∏è Collections d√©j√† existantes")
            return True
        else:
            print(f"  ‚ùå Erreur cr√©ation collections: {str(e)}")
            return False

async def create_elo_indexes():
    """Cr√©er les index optimis√©s pour le syst√®me ELO"""
    try:
        print("üìö Cr√©ation des index pour optimiser les performances...")
        
        # Index pour elo_ratings
        await db.elo_ratings.create_index([("user_id", 1), ("game", 1), ("mode", 1), ("season", 1)], unique=True)
        await db.elo_ratings.create_index([("rating", -1)])  # Pour leaderboards
        await db.elo_ratings.create_index([("tier", 1)])
        await db.elo_ratings.create_index([("last_match_date", 1)])  # Pour d√©clin d'inactivit√©
        await db.elo_ratings.create_index([("season", 1)])
        
        # Index pour elo_matches
        await db.elo_matches.create_index([("winner_id", 1), ("played_at", -1)])
        await db.elo_matches.create_index([("loser_id", 1), ("played_at", -1)])
        await db.elo_matches.create_index([("match_id", 1)])
        await db.elo_matches.create_index([("tournament_id", 1)])
        await db.elo_matches.create_index([("game", 1), ("played_at", -1)])
        await db.elo_matches.create_index([("season", 1)])
        
        # Index pour season_stats
        await db.season_stats.create_index([("user_id", 1), ("season", 1), ("game", 1)], unique=True)
        
        print("  ‚úÖ Index cr√©√©s avec succ√®s")
        return True
        
    except Exception as e:
        print(f"  ‚ùå Erreur cr√©ation index: {str(e)}")
        return False

async def initialize_user_elo_ratings():
    """Initialiser les ratings ELO de base pour les utilisateurs existants"""
    try:
        print("üë• Initialisation des ratings ELO pour les utilisateurs existants...")
        
        # R√©cup√©rer tous les utilisateurs
        users = await db.users.find({"role": {"$ne": "admin"}}).to_list(1000)
        
        if not users:
            print("  ‚ÑπÔ∏è Aucun utilisateur trouv√©")
            return True
        
        CURRENT_SEASON = "2025-S1"
        games = ["cs2", "lol", "wow", "sc2", "minecraft"]
        mode = "tournament"
        
        ratings_created = 0
        
        for user in users:
            user_id = user["id"]
            username = user.get("username", "Utilisateur")
            
            # Cr√©er un rating ELO principal pour CS2 (jeu principal)
            main_rating = {
                "id": str(uuid.uuid4()),
                "user_id": user_id,
                "game": "cs2",
                "mode": mode,
                "rating": random.randint(1100, 1300),  # Variation r√©aliste autour de 1200
                "peak_rating": 1200,
                "matches_played": random.randint(0, 5),  # Nouveaux joueurs
                "wins": 0,
                "losses": 0,
                "win_rate": 0.0,
                "tier": "silver",
                "tier_progress": random.randint(0, 100),
                "season": CURRENT_SEASON,
                "last_match_date": None,
                "created_at": datetime.utcnow(),
                "updated_at": datetime.utcnow()
            }
            
            # Ajuster peak_rating au rating initial
            main_rating["peak_rating"] = main_rating["rating"]
            
            # Calculer le tier correct
            rating = main_rating["rating"]
            if rating < 1000:
                main_rating["tier"] = "bronze"
            elif rating < 1200:
                main_rating["tier"] = "silver"
            elif rating < 1400:
                main_rating["tier"] = "gold"
            else:
                main_rating["tier"] = "platinum"
            
            try:
                # Ins√©rer seulement si n'existe pas d√©j√†
                existing = await db.elo_ratings.find_one({
                    "user_id": user_id,
                    "game": "cs2",
                    "mode": mode,
                    "season": CURRENT_SEASON
                })
                
                if not existing:
                    await db.elo_ratings.insert_one(main_rating)
                    ratings_created += 1
                    
                    # Mettre √† jour le profil utilisateur avec l'ELO initial
                    await db.user_profiles.update_one(
                        {"user_id": user_id},
                        {
                            "$set": {
                                "elo_rating": rating,
                                "peak_elo": rating,
                                "elo_tier": main_rating["tier"],
                                "elo_tier_progress": main_rating["tier_progress"],
                                "updated_at": datetime.utcnow()
                            }
                        },
                        upsert=True
                    )
                
            except Exception as e:
                print(f"  ‚ùå Erreur pour {username}: {str(e)}")
                continue
        
        print(f"  ‚úÖ {ratings_created} ratings ELO cr√©√©s pour {len(users)} utilisateurs")
        return True
        
    except Exception as e:
        print(f"  ‚ùå Erreur initialisation ratings utilisateurs: {str(e)}")
        return False

async def create_sample_elo_matches():
    """Cr√©er quelques matchs d'exemple pour d√©monstration"""
    try:
        print("‚öîÔ∏è Cr√©ation de matchs d'exemple...")
        
        # V√©rifier s'il y a d√©j√† des matchs
        existing_matches = await db.elo_matches.count_documents({})
        if existing_matches > 0:
            print(f"  ‚ÑπÔ∏è {existing_matches} matchs d√©j√† pr√©sents")
            return True
        
        # R√©cup√©rer quelques utilisateurs
        users = await db.users.find({"role": {"$ne": "admin"}}).limit(6).to_list(6)
        if len(users) < 2:
            print("  ‚ÑπÔ∏è Pas assez d'utilisateurs pour cr√©er des matchs d'exemple")
            return True
        
        matches_created = 0
        CURRENT_SEASON = "2025-S1"
        
        # Cr√©er 3 matchs d'exemple
        for i in range(3):
            if i * 2 + 1 >= len(users):
                break
                
            winner = users[i * 2]
            loser = users[i * 2 + 1]
            
            # R√©cup√©rer les ratings actuels
            winner_rating_doc = await db.elo_ratings.find_one({
                "user_id": winner["id"],
                "game": "cs2",
                "season": CURRENT_SEASON
            })
            
            loser_rating_doc = await db.elo_ratings.find_one({
                "user_id": loser["id"],
                "game": "cs2",
                "season": CURRENT_SEASON
            })
            
            if not winner_rating_doc or not loser_rating_doc:
                continue
            
            winner_rating = winner_rating_doc["rating"]
            loser_rating = loser_rating_doc["rating"]
            
            # Simuler un changement de rating simple
            rating_change = random.randint(15, 35)
            new_winner_rating = winner_rating + rating_change
            new_loser_rating = max(800, loser_rating - rating_change)
            
            # Cr√©er le match d'exemple
            sample_match = {
                "id": str(uuid.uuid4()),
                "match_id": f"sample_match_{i + 1}",
                "tournament_id": None,
                "game": "cs2",
                "mode": "tournament",
                "winner_id": winner["id"],
                "loser_id": loser["id"],
                "winner_rating_before": winner_rating,
                "loser_rating_before": loser_rating,
                "winner_rating_after": new_winner_rating,
                "loser_rating_after": new_loser_rating,
                "rating_change": rating_change,
                "match_importance": 1.0,
                "season": CURRENT_SEASON,
                "played_at": datetime.utcnow() - timedelta(days=random.randint(1, 7))
            }
            
            await db.elo_matches.insert_one(sample_match)
            
            # Mettre √† jour les ratings des joueurs
            await db.elo_ratings.update_one(
                {"user_id": winner["id"], "game": "cs2", "season": CURRENT_SEASON},
                {
                    "$set": {
                        "rating": new_winner_rating,
                        "peak_rating": max(winner_rating_doc.get("peak_rating", winner_rating), new_winner_rating),
                        "last_match_date": sample_match["played_at"],
                        "updated_at": datetime.utcnow()
                    },
                    "$inc": {"matches_played": 1, "wins": 1}
                }
            )
            
            await db.elo_ratings.update_one(
                {"user_id": loser["id"], "game": "cs2", "season": CURRENT_SEASON},
                {
                    "$set": {
                        "rating": new_loser_rating,
                        "last_match_date": sample_match["played_at"],
                        "updated_at": datetime.utcnow()
                    },
                    "$inc": {"matches_played": 1, "losses": 1}
                }
            )
            
            matches_created += 1
            
            print(f"    Match {i + 1}: {winner.get('username', 'User1')} bat {loser.get('username', 'User2')} ({winner_rating} -> {new_winner_rating}, {loser_rating} -> {new_loser_rating})")
        
        print(f"  ‚úÖ {matches_created} matchs d'exemple cr√©√©s")
        return True
        
    except Exception as e:
        print(f"  ‚ùå Erreur cr√©ation matchs d'exemple: {str(e)}")
        return False

async def verify_elo_system():
    """V√©rifier que le syst√®me ELO est bien configur√©"""
    try:
        print("üîç V√©rification du syst√®me ELO...")
        
        # V√©rifier les collections
        collections = await db.list_collection_names()
        required_collections = ["elo_ratings", "elo_matches", "season_stats"]
        
        for collection in required_collections:
            if collection in collections:
                count = await db[collection].count_documents({})
                print(f"  ‚úÖ Collection '{collection}': {count} documents")
            else:
                print(f"  ‚ùå Collection '{collection}' manquante")
                return False
        
        # V√©rifier les index
        elo_ratings_indexes = await db.elo_ratings.list_indexes().to_list(100)
        print(f"  ‚úÖ {len(elo_ratings_indexes)} index cr√©√©s pour elo_ratings")
        
        elo_matches_indexes = await db.elo_matches.list_indexes().to_list(100)
        print(f"  ‚úÖ {len(elo_matches_indexes)} index cr√©√©s pour elo_matches")
        
        # Statistiques des ratings
        total_ratings = await db.elo_ratings.count_documents({})
        if total_ratings > 0:
            avg_rating = await db.elo_ratings.aggregate([
                {"$group": {"_id": None, "avg": {"$avg": "$rating"}}}
            ]).to_list(1)
            
            avg_rating_value = avg_rating[0]["avg"] if avg_rating else 1200
            print(f"  üìä Rating ELO moyen: {avg_rating_value:.1f}")
            
            # Distribution par tier
            tier_pipeline = [
                {"$group": {"_id": "$tier", "count": {"$sum": 1}}},
                {"$sort": {"count": -1}}
            ]
            tier_dist = await db.elo_ratings.aggregate(tier_pipeline).to_list(10)
            print(f"  üèÜ Distribution par tier:")
            for tier_info in tier_dist:
                print(f"      {tier_info['_id'].capitalize()}: {tier_info['count']} joueurs")
        
        print("üìä Syst√®me ELO pr√™t √† l'emploi !")
        return True
        
    except Exception as e:
        print(f"  ‚ùå Erreur v√©rification: {str(e)}")
        return False

async def main():
    """Fonction principale d'initialisation"""
    print("üìä INITIALISATION DU SYST√àME ELO AUTOMATIQUE")
    print("=" * 60)
    
    try:
        # Tester la connexion √† la base de donn√©es
        await db.command("ping")
        print("‚úÖ Connexion √† MongoDB r√©ussie")
        
        # √âtapes d'initialisation
        steps = [
            ("Cr√©ation des collections", create_elo_collections),
            ("Initialisation ratings utilisateurs", initialize_user_elo_ratings),
            ("Matchs d'exemple", create_sample_elo_matches),
            ("V√©rification syst√®me", verify_elo_system)
        ]
        
        for step_name, step_func in steps:
            print(f"\nüìã {step_name}...")
            success = await step_func()
            if not success:
                print(f"‚ùå √âchec de l'√©tape: {step_name}")
                return False
        
        print("\n" + "=" * 60)
        print("üéâ INITIALISATION DU SYST√àME ELO TERMIN√âE AVEC SUCC√àS !")
        print("\nNouvelles fonctionnalit√©s disponibles:")
        print("  üìä Syst√®me de classement ELO complet")
        print("  üèÜ 8 tiers de classement (Bronze √† Challenger)")
        print("  ‚öîÔ∏è Traitement automatique des r√©sultats de matchs")
        print("  üìà Historique d√©taill√© des matchs et √©volution ELO")
        print("  üéØ Classements par jeu et mode de jeu")
        print("  üë®‚Äçüíº Interface d'administration pour gestion manuelle")
        print("  üîÑ Syst√®me de d√©gradation pour inactivit√©")
        print("  üèÖ Int√©gration automatique avec les tournois")
        
        return True
        
    except Exception as e:
        print(f"\n‚ùå ERREUR FATALE: {str(e)}")
        return False
    
    finally:
        client.close()

if __name__ == "__main__":
    success = asyncio.run(main())
    exit(0 if success else 1)